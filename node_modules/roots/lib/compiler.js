// Generated by CoffeeScript 1.10.0
(function() {
  var CompileFile, CompilePass, Compiler, File, W, _, fs, mkdirp, nodefn, path, pipeline, sequence;

  fs = require('graceful-fs');

  path = require('path');

  _ = require('lodash');

  W = require('when');

  nodefn = require('when/node');

  pipeline = require('when/pipeline');

  sequence = require('when/sequence');

  File = require('vinyl');

  mkdirp = require('mkdirp');


  /**
   * @class Compiler
   * @classdesc Responsible for compiling files, multipass included
   */

  Compiler = (function() {

    /**
     * Creates a new compiler instance, which holds on to the roots instance
     * as well as an array of initialized extensions, and creates an empty
     * options object, which is re-created per-compile.
     *
     * @param  {Function} @roots - Roots class instance
     * @param  {Function} @extensions - array of initialzed extensions
     */
    function Compiler(roots, extensions1) {
      this.roots = roots;
      this.extensions = extensions1;
      this.options = {};
    }


    /**
     * Compile a single file asynchronously.
     *
     * @param  {String} category - category the file is being compiled in
     * @param  {File} file - vinyl-wrapped file
     * @return {Promise} promise for the fully compiled file
     */

    Compiler.prototype.compile = function(category, file) {
      var cf;
      cf = new CompileFile(this.roots, this.extensions, this.options, category, file);
      return cf.run();
    };

    return Compiler;

  })();

  module.exports = Compiler;


  /**
   * @class CompileFile
   * @classdesc Compiles a single file, separate class to allow for working
   *            easily with a scope that doesn't interfere with anything else.
   * @private
   */

  CompileFile = (function() {

    /**
     * Creates a new instances of the CompileFile class. Grabs the adapter(s)
     * needed to compile the file, creates the per-file options object and adds
     * filename to it.
     *
     * @param  {Function} roots           Roots class instance
     * @param  {Array}    extensions      Array of initialzed extensions
     * @param  {Object}   compile_options Per-compile options object
     * @param  {String}   category        Category of file being compiled
     * @param  {File}     file            Vinyl-wrapped file
     */
    var each_pass, get_adapters, process_write_hook_results, read_file, url_path, write_file, write_sourcemaps_if_present, write_task;

    function CompileFile(roots, extensions1, compile_options1, category1, file1) {
      this.roots = roots;
      this.extensions = extensions1;
      this.compile_options = compile_options1;
      this.category = category1;
      this.file = file1;
      this.adapters = get_adapters.call(this);
      this.is_compiled = !!_(this.adapters).map('name').compact().value().length;
      this.out_ext = _.last(this.adapters).output;
      this.file_options = {
        filename: this.file.path,
        _path: url_path.call(this)
      };
    }


    /**
     * Initialize the actual compilation. This method is a higher level wrapper
     * for a promise chain, summarized as such:
     *
     * - reads the file's content, set on the instance
     * - run the before hooks for each extensions before_file hook
     * - take each pass over the file, compile, set compiled content on instance
     * - emit a compile event once finished passing the file vinyl wrapper
     * - run the extensions' after hooks
     * - write the file
     *
     * @return {Promise} promise for a compiled and written file
     */

    CompileFile.prototype.run = function() {
      var hooks;
      hooks = (function(_this) {
        return function(cat) {
          return _this.extensions.hooks(cat, _this.category);
        };
      })(this);
      return read_file.call(this, this.file)["with"](this).then((function(_this) {
        return function(o) {
          return _this.content = o;
        };
      })(this)).then((function(_this) {
        return function() {
          return sequence(hooks('compile_hooks.before_file'), _this);
        };
      })(this)).then(each_pass).tap((function(_this) {
        return function(o) {
          _this.content = o.result;
          return _this.sourcemap = o.sourcemap;
        };
      })(this)).tap((function(_this) {
        return function() {
          return _this.roots.emit('compile', _this.file);
        };
      })(this)).then((function(_this) {
        return function() {
          return sequence(hooks('compile_hooks.after_file'), _this);
        };
      })(this)).then(write_file);
    };


    /**
     * Async utf8 file read from a vinyl file wrapped in a promise.
     *
     * @private
     *
     * @param  {f} f - vinyl-wrapped file
     * @return {Promise} a promise for the file's contents
     */

    read_file = function(f) {
      var options, opts;
      options = null;
      opts = this.is_compiled ? {
        encoding: 'utf8'
      } : null;
      return nodefn.call(fs.readFile, f.path, opts);
    };


    /**
     * Writes a file from the content property on the instance. Can be modified
     * by a write_hook from an extension.
     *
     * - Run through extension write hooks
     * - Process the results of each and create write tasks (see below)
     * - Move on once all write tasks have been completed
     *
     * @private
     *
     * @return {Promise} promise for written file(s)
     *
     * @todo adjust config.out to work better with vinyl
     */

    write_file = function() {
      return sequence(this.extensions.hooks('compile_hooks.write', this.category), this).then(process_write_hook_results.bind(this)).then(write_sourcemaps_if_present.bind(this)).then(W.all);
    };


    /**
     * Given an array of results from each extension's write_hook, if
     * present, figure out how to handle the actual writes, then delegate
     * them to one or multiple `write_task`s.
     *
     * - If there are no write hooks, file is written as usual
     * - If a write hook returns false, file is not written ever
     * - If a write hook returns true, file is written as usual (once at max)
     * - If a write hook returns an object or array of objects with
     *   path and content props, the file(s) is/are written to the
     *   provided path(s) with the provided content(s)
     * - If a write hook returns anything else, roots bails
     *
     * We then return an array of promises for all write tasks.
     *
     * @param  {Array} results - results from all write hooks
     * @return {Array} an array of promises for written files
     *
     * @todo if custom path is given, it always also writes standard
     */

    process_write_hook_results = function(results) {
      var j, len, normal_write_pushed, res, write_tasks;
      if (results.length < 1) {
        return [write_task.call(this)];
      }
      if (_.includes(results, false)) {
        return [];
      }
      write_tasks = [];
      normal_write_pushed = false;
      for (j = 0, len = results.length; j < len; j++) {
        res = results[j];
        if (res === true) {
          if (!normal_write_pushed) {
            write_tasks.push(write_task.call(this));
          }
          normal_write_pushed = true;
        } else if (typeof res === 'object' && !Array.isArray(res)) {
          write_tasks.push(write_task.call(this, res));
        } else if (Array.isArray(res)) {
          write_tasks.concat(res.map((function(_this) {
            return function(i) {
              return write_task.call(_this, i);
            };
          })(this)));
        } else {
          this.roots.bail(126, 'invalid return from write_hook', res);
        }
      }
      return W.resolve(write_tasks);
    };

    write_sourcemaps_if_present = function(tasks) {
      var f;
      if (!this.sourcemap) {
        return tasks;
      }
      f = new File({
        base: this.roots.root,
        path: this.file.path + '.map'
      });
      tasks.push(write_task.call(this, {
        path: f,
        content: JSON.stringify(this.sourcemap),
        sourcemap: true
      }));
      return W.resolve(tasks);
    };


    /**
     * Single task to write a file. Accepts an optional object with the following
     * keys:
     *
     * - path: relative (to root) or absolute path to write to
     * - content: content to write
     * - extension: extension to write the file with
     *
     * If an object is passed, each of these keys is optional, and if not provided
     * will be filled in with default values. The path then is wrapped with vinyl,
     * passed through the roots output path generator, and the file is written.
     * The extension property is only set if there wasn't already an extension
     * override and there was a compile, otherwise any extensions are preserved as
     * is.
     *
     * If there is a sourcemap for one of the files being written, two things need
     * to happen. First, the sourcemap needs to be written with a .map extension.
     * Second, the output file needs to get a source mapping url comment so that
     * it knows where the sourcemap is. Both of these things happen as well in
     * this method.
     *
     * @param  {Object} obj - object with `path` and `content` properties
     * @return {Promise} a promise for the written file
     */

    write_task = function(obj) {
      if (obj == null) {
        obj = {};
      }
      obj = _.defaults(obj, {
        path: this.file,
        content: this.content
      });
      if ((obj.extension == null) && this.is_compiled) {
        obj.extension = this.out_ext;
      }
      if (obj.sourcemap != null) {
        obj.extension += '.map';
      }
      if (!(obj.path instanceof File)) {
        obj.path = new File({
          base: this.roots.root,
          path: obj.path
        });
      }
      obj.path = this.roots.config.out(obj.path, obj.extension);
      if (this.sourcemap && (obj.sourcemap == null)) {
        if (this.out_ext === 'css') {
          obj.content = obj.content + "\n /*# sourceMappingURL=" + (path.basename(obj.path)) + ".map */";
        }
        if (this.out_ext === 'js') {
          obj.content = obj.content + "\n //# sourceMappingURL=" + (path.basename(obj.path)) + ".map";
        }
      }
      return nodefn.call(mkdirp, path.dirname(obj.path)).then(function() {
        return nodefn.call(fs.writeFile, obj.path, obj.content);
      });
    };


    /**
     * Read the file's extension and grab any and all adapters that match. If
     * there isn't a matching adapter, returns an adapter stub that is used to
     * just copy the file.
     *
     * If no adapters are found, it's a file with no extension, so it gets a stub
     * adapter with no extension.
     *
     * @return {Array} an array of adapter objects, in order
     */

    get_adapters = function() {
      var adapters, compiler, ext, extensions, j, len, ref;
      extensions = path.basename(this.file.path).split('.').slice(1);
      adapters = [];
      ref = _.clone(extensions).reverse();
      for (j = 0, len = ref.length; j < len; j++) {
        ext = ref[j];
        compiler = _.find(this.roots.config.compilers, function(c) {
          return _.includes(c.extensions, ext);
        });
        adapters.push(compiler ? compiler : {
          output: ext
        });
      }
      if (!adapters.length) {
        adapters.push({
          output: ''
        });
      }
      return adapters;
    };


    /**
     * Initializes the actual compilation of the file. Since each pass is it's
     * own task, it gets its own context. This method runs pipeline, which runs
     * through an array and passes one's output to the next. Before doing this,
     * it binds an adapter and an index to each compile pass.
     *
     * @return {Promise} a promise for the compiled content of the file
     */

    each_pass = function() {
      var pass;
      pass = new CompilePass(this);
      return pipeline(this.adapters.map(function(a, i) {
        return pass.run.bind(pass, a, i + 1);
      }), {
        result: this.content
      });
    };


    /**
     * Returns the absolute path to the file as requested through the browser,
     * excluding the hostname, port, etc.
     *
     * @return {String} the absolute URL as requested through the browser
     *
     */

    url_path = function() {
      var f, out_path, p;
      f = new File({
        base: this.roots.root,
        path: this.file.path
      });
      out_path = this.roots.config.out(f, this.out_ext);
      p = path.relative(path.join(this.roots.root, this.roots.config.output), out_path);
      return "/" + (p.replace(path.sep, '/'));
    };

    return CompileFile;

  })();


  /**
   * @class CompilePass
   * @classdesc Handles one compilation pass on a file's content.
   */

  CompilePass = (function() {

    /**
     * Creates a new instance, holding on to a ref to the CompileFile instance.
     * @param  {Function} file - instance of CompileFile
     */
    var compile_or_pass, configure_options;

    function CompilePass(file1) {
      this.file = file1;
    }


    /**
     * Initialize the compile. Takes an adapter, the index (number of the pass),
     * and content. It takes a couple steps:
     *
     * - First, get the options to be passed in with the adapter, described below
     * - Then execute any before pass hooks
     * - Then actually compile, or if not needed just pass the content on
     * - Then set the content on the context
     * - Then execute any after_pass hooks
     * - Finally, return the content
     *
     * @param  {Object} @adapter - accord adapter to compile with
     * @param  {Integer} @index - # of the compile pass
     * @param  {String} @content - the content to be compiled
     * @return {Promise} a promise for the compiled content
     *
     * @todo is there a way to yield(@content)?
     */

    CompilePass.prototype.run = function(adapter, index, input) {
      var hooks;
      this.adapter = adapter;
      this.index = index;
      this.input = input;
      hooks = (function(_this) {
        return function(cat) {
          return _this.file.extensions.hooks(cat, _this.file.category);
        };
      })(this);
      this.content = this.input.result;
      return sequence(hooks('compile_hooks.before_pass'), this)["with"](this).tap((function(_this) {
        return function() {
          return _this.opts = configure_options.call(_this);
        };
      })(this)).then(compile_or_pass).then((function(_this) {
        return function(o) {
          var res;
          _this.content = o.result;
          res = {
            result: _this.content
          };
          if (o.sourcemap) {
            _this.sourcemap = o.sourcemap;
            res.sourcemap = _this.sourcemap;
          }
          return res;
        };
      })(this)).tap((function(_this) {
        return function() {
          return sequence(hooks('compile_hooks.after_pass'), _this);
        };
      })(this));
    };


    /**
     * This function is responsible for getting all the options together for the
     * compilation. Tried to be clear as possible here with the code, as you can
     * see there are 4 different options objects that are merged together to make
     * the package of options that are passed in for each file.
     *
     * - global options: set in app.coffee, these are options that are present in
     *   every file, no matter what
     * - adapter options: also set in app.coffee, these options are specific to an
     *   adapter. For example, setting `pretty` to `true` for jade only
     * - file options: options that persist only for a single file, for all passes
     * - compile options: options that persist through each time the project
     *   compiles, but are cleared between one compile and the next
     *
     * @private
     *
     * @return {Object} - all options merged into a single object
     */

    configure_options = function() {
      var adapter_options, compile_options, file_options, global_options, ref, ref1;
      global_options = (ref = this.file.roots.config.locals) != null ? ref : {};
      adapter_options = (ref1 = this.file.roots.config[this.adapter.name]) != null ? ref1 : {};
      file_options = this.file.file_options;
      compile_options = this.file.compile_options;
      return _.extend({}, global_options, adapter_options, file_options, compile_options);
    };


    /**
     * As small of a function as this is, it's the one that actually is doing
     * the work to compile the files. First it checks if the adapter has a name,
     * which is a requirement of all accord adapters. If not, it's likely a stub
     * adapter used to copy the file, and it returns the content.
     *
     * If there is a name this means we have a legit adapter, and it runs the
     * compile and returns a promise for the content.
     *
     * @return {Promise|String} a string or promise for a string of content
     *
     * @todo maybe use instance rather than name to classify?
     */

    compile_or_pass = function() {
      if (!this.adapter.name) {
        return this.input;
      }
      if (!this.content.length) {
        return this.input;
      }
      return this.adapter.render(this.content, this.opts);
    };

    return CompilePass;

  })();

}).call(this);
