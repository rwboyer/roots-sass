'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _utils = require('./utils');

var _utils2 = _interopRequireDefault(_utils);

var _helpers = require('./helpers');

var _when = require('when');

var _when2 = _interopRequireDefault(_when);

var _node = require('when/node');

var _node2 = _interopRequireDefault(_node);

var _which = require('which');

var _which2 = _interopRequireDefault(_which);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _jsYaml = require('js-yaml');

var _jsYaml2 = _interopRequireDefault(_jsYaml);

var _minimatch = require('minimatch');

var _minimatch2 = _interopRequireDefault(_minimatch);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _joi = require('joi');

var _joi2 = _interopRequireDefault(_joi);

var _rimraf2 = require('rimraf');

var _rimraf3 = _interopRequireDefault(_rimraf2);

var _readdirp2 = require('readdirp');

var _readdirp3 = _interopRequireDefault(_readdirp2);

var _fs2 = require('fs');

var _fs3 = _interopRequireDefault(_fs2);

var _dns2 = require('dns');

var _dns3 = _interopRequireDefault(_dns2);

var _child_process = require('child_process');

var _ncp2 = require('ncp');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var rimraf = _node2.default.lift(_rimraf3.default);
var exec = _node2.default.lift(_child_process.exec);
var readdirp = _node2.default.lift(_readdirp3.default);
var ncp = _node2.default.lift(_ncp2.ncp);
var fs = _node2.default.liftAll(_fs3.default, function (pfs, lifted, name) {
  pfs[name + 'Async'] = lifted;
  return pfs;
});
var dns = _node2.default.liftAll(_dns3.default);

/*
 * Given a Sprout instance and a name, returns a Template instance.
 * @param {Function} sprout - Sprout instance.
 * @param {String} name - Name of template
 * @param {String} src (optional) - Path or URL to source. Only required for
 * `template.save`.
 * @return {Function} - Template instance.
 */

var Template = function () {
  function Template(_options) {
    _classCallCheck(this, Template);

    var schema = _joi2.default.object().keys({
      sprout: _joi2.default.any().required(),
      name: _joi2.default.string().required(),
      src: _joi2.default.string(),
      rootFolderName: _joi2.default.string().default('root'),
      generatorsFolderName: _joi2.default.string().default('generators')
    });

    var options = _joi2.default.validate(_options, schema, {
      language: {
        messages: { wrapArrays: false },
        object: { child: '!![sprout constructor] option {{reason}}' }
      }
    });
    if (options.error) {
      throw options.error;
    }
    options = options.value;

    this.sprout = options.sprout;
    this.name = options.name;
    this.path = _path2.default.join(this.sprout.path, this.name);
    this.rootPath = _path2.default.join(this.path, options.rootFolderName);
    this.generatorsPath = _path2.default.join(this.path, options.generatorsFolderName);
    this.src = options.src;
    if (this.src) {
      this.isRemote = (0, _helpers.isGitUrl)(this.src);
    }
  }

  /*
   * Saves `template.src` to `template.path`
   * @return {Promise} - promise for Template instance.
   */


  _createClass(Template, [{
    key: 'save',
    value: function save() {
      return _when2.default.resolve().with(this).then(ensureGitInstall).then(validateSource).then(ensureInternetConnection).then(removeTemplate).then(moveSourceToSproutPath).yield(this);
    }

    /*
     * Initialize template and save to `target`
     * @param {String} target - The path to save the template to.
     * @return {Promise} - Promise for Template instance.
     */

  }, {
    key: 'init',
    value: function init(target) {
      var _this = this;

      var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      var utils = new _utils2.default(this.path, target);
      var schema = _joi2.default.object().keys({
        locals: _joi2.default.object().default({}),
        tag: _joi2.default.string(),
        branch: _joi2.default.string(),
        configPath: _joi2.default.string(),
        questionnaire: _joi2.default.func()
      });

      _joi2.default.assert(target, _joi2.default.string().required().label('target'));

      return _node2.default.call(_joi2.default.validate, opts, schema, {
        language: {
          messages: { wrapArrays: false },
          object: { child: '!![sprout init] option {{reason}}' }
        }
      }).with(this).then(function (res) {
        opts = res;
      }).then(this.update.bind(this)).then(validateTemplate).then(validateTarget.bind(this, target)).then(handleBranchOrTagOption.bind(this, opts)).then(createTargetDirectory.bind(this, target)).then(installDependenciesIfPresent).then(function () {
        return _when2.default.resolve().with(_this).then(loadConfigFile).then(runBeforeHook.bind(_this, utils)).then(mergeConfig.bind(_this, opts)).then(runPrompts.bind(_this, opts)).then(copyTemplateToTarget.bind(_this, target)).then(runBeforeRenderHook.bind(_this, utils)).then(readTemplateFiles.bind(_this, target)).then(removeIgnoredFiles).then(writeTemplateFiles.bind(_this, utils)).then(runAfterHook.bind(_this, utils)).then(checkoutBranchIfPresent.bind(_this, _this.currentBranch)).catch(function (err) {
          return rimraf(target).then(function () {
            throw err;
          });
        });
      }).yield(this);
    }

    /*
     * Update template source.
     * @return {Promise} - Promise for Template instance.
     */

  }, {
    key: 'update',
    value: function update() {
      var _this2 = this;

      // Confirm template is a git repository. If not, don't type to update.
      if (!fs.existsSync(_path2.default.join(this.path, '.git'))) {
        return _when2.default.resolve(this);
      }

      // If remote origin exists, run `git remote update` to update the
      // repository.
      this.sprout.emit('msg', 'updating template');
      this.sprout.emit('cmd', 'git remote', this.path);

      return exec('git remote', { cwd: this.path }).then(function (stdout) {
        if (!stdout[0]) {
          return;
        }
        var origin = _lodash2.default.trim(stdout[0]);
        _this2.sprout.emit('cmd', 'git pull ' + origin + ' HEAD', _this2.path);
        return exec('git pull ' + origin + ' HEAD', { cwd: _this2.path });
      }).yield(this);
    }

    /*
     * Run a template generator in the specified target.
     * @param {String} target - the target path.
     * @param {String} name - the name of the generator to use.
     * @param {Object} args - arguments to be passed to the generator
     * @return {Promise} - Promise for Template instance.
     */

  }, {
    key: 'run',
    value: function run(target, generator, _args) {
      var args = { target: target, generator: generator, generatorArgs: _args };
      var schema = _joi2.default.object().keys({
        target: _joi2.default.string().required(),
        generator: _joi2.default.string().required(),
        generatorArgs: _joi2.default.array().single().default([])
      });

      return _node2.default.call(_joi2.default.validate, args, schema, {
        language: {
          messages: { wrapArrays: false },
          object: { child: '!![sprout generator] option {{reason}}' }
        }
      }).then(function (res) {
        args = res;
      }).then(function () {
        if (!fs.existsSync(target)) {
          throw new Error(target + ' does not exist');
        }
      }).then(validateGenerator.bind(this, args.generator)).then(executeGenerator.bind(this, args.target, args.generatorArgs)).yield(this);
    }

    /*
     * Delete the template.
     * @return {Promise} - Promise for Template instance.
     */

  }, {
    key: 'remove',
    value: function remove() {
      var _this3 = this;

      // Resolve if path does not exist.
      if (!fs.existsSync(this.path)) {
        return _when2.default.resolve(this);
      }

      // rm -rf the path.
      this.sprout.emit('msg', 'removing template');

      return fs.lstatAsync(this.path).then(function (stat) {
        if (stat.isSymbolicLink()) {
          return fs.unlink(_this3.path);
        }
        return rimraf(_this3.path);
      }).yield(this);
    }
  }]);

  return Template;
}();

//
// Utility Functions
//

function ensureGitInstall() {
  // Check if git is installed
  if (!_which2.default.sync('git')) {
    throw new Error('you need to have git installed');
  }
}

function validateSource() {
  if (!this.src) {
    throw new Error('no source provided');
  }

  if (!this.isRemote && !fs.existsSync(this.src)) {
    throw new Error('there is no sprout template located at ' + this.src);
  }

  if (!this.isRemote && !fs.existsSync(_path2.default.join(this.src, '.git'))) {
    throw new Error(this.src + ' is not a git repository');
  }
}

// TODO is this needed? could replace with timeout
function ensureInternetConnection() {
  if (!this.isRemote) {
    return;
  }
  return dns.resolve('google.com').catch(function () {
    throw new Error('make sure that you are connected to the internet!');
  });
}

function removeTemplate() {
  return this.remove();
}

function moveSourceToSproutPath() {
  if (this.isRemote) {
    this.sprout.emit('cmd', 'git clone ' + this.src + ' ' + this.path);
    return exec('git clone --recursive ' + this.src + ' ' + this.path);
  }

  return fs.symlinkAsync(this.src, this.path);
}

function validateTemplate() {
  if (!fs.existsSync(_path2.default.join(this.path, 'init.js'))) {
    throw new Error('init.js does not exist in this template');
  }

  if (!fs.existsSync(this.rootPath)) {
    throw new Error('root path does not exist in template');
  }
}

function validateTarget(target) {
  if (fs.existsSync(target)) {
    throw new Error(target + ' already exists');
  }
}

function handleBranchOrTagOption(opts) {
  var _this4 = this;

  if (!(opts.tag || opts.branch)) {
    return;
  }

  this.sprout.emit('cmd', 'git rev-parse --abbrev-ref HEAD', this.path);

  return exec('git rev-parse --abbrev-ref HEAD', { cwd: this.path }).spread(function (stdout) {
    _this4.currentBranch = stdout;
  }).then(checkoutBranchIfPresent.bind(this, opts.branch)).then(checkoutTagIfPresent.bind(this, opts.tag));
}

function checkoutBranchIfPresent(branch) {
  if (!branch) {
    return;
  }
  this.sprout.emit('cmd', 'git checkout ' + branch, this.path);
  return exec('git checkout ' + branch, { cwd: this.path });
}

function checkoutTagIfPresent(tag) {
  if (!tag) {
    return;
  }
  this.sprout.emit('cmd', 'git checkout tags/' + tag, this.path);
  return exec('git checkout tags/' + tag, { cwd: this.path });
}

function createTargetDirectory(target) {
  this.sprout.emit('msg', 'creating target directory: ' + target);
  return fs.mkdir(target);
}

function installDependenciesIfPresent() {
  var pkgPath = _path2.default.join(this.path, 'package.json');
  if (!fs.existsSync(pkgPath)) {
    return;
  }
  var pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf8'));
  if (!pkg.dependencies) {
    return;
  }
  this.sprout.emit('msg', 'installing npm dependencies');
  return exec('npm install --production', { cwd: this.path });
}

function loadConfigFile() {
  var initPath = _path2.default.join(this.path, 'init.js');

  this.sprout.emit('msg', 'requiring and validating ' + initPath);

  var schema = _joi2.default.object().keys({
    before: _joi2.default.func(),
    configure: _joi2.default.array().items(_joi2.default.object()),
    beforeRender: _joi2.default.func(),
    after: _joi2.default.func(),
    ignore: _joi2.default.array().single(),
    defaults: _joi2.default.object()
  });

  var result = _joi2.default.validate(require(initPath), schema, {
    language: {
      messages: { wrapArrays: false },
      object: { child: '!![sprout init.js] option {{reason}}' }
    }
  });
  if (result.error) {
    throw result.error;
  }

  this.init = result.value;
}

function runBeforeHook(utils) {
  if (this.init.before) {
    this.sprout.emit('msg', 'running before hook');
    return (0, _when2.default)(this.init.before(utils, this.config));
  }
}

function mergeConfig(opts) {
  this.config = {};

  // Merge in all known values for config.
  _lodash2.default.assign(this.config, this.init.defaults, opts.locals);

  // If a config path is set, pull out its values and merge into config.
  if (opts.configPath) {
    this.sprout.emit('msg', 'merging config: ' + opts.configPath);
    var externalConfig = void 0;

    if (/\.json$/.test(opts.configPath)) {
      externalConfig = require(opts.configPath);
    } else {
      externalConfig = _jsYaml2.default.safeLoad(fs.readFileSync(opts.configPath, 'utf8'));
    }

    _lodash2.default.assign(this.config, externalConfig);
  }
}

// If questionnaire function exists, run it to get answers.
// Omitting keys already set in config return answers merged with config values.
function runPrompts(opts) {
  var _this5 = this;

  if (opts.questionnaire && this.init.configure) {
    this.sprout.emit('msg', 'running questionnaire function');
    var unansweredConfig = _lodash2.default.filter(this.init.configure, function (q) {
      return !_lodash2.default.includes(_lodash2.default.keys(_this5.config), q.name);
    });
    return opts.questionnaire(unansweredConfig).then(function (answers) {
      return _lodash2.default.assign(_this5.config, answers);
    });
  }
}

function copyTemplateToTarget(target) {
  this.sprout.emit('msg', 'copying files in root to target');
  return ncp(this.rootPath, target);
}

function runBeforeRenderHook(utils) {
  if (this.init.beforeRender) {
    this.sprout.emit('msg', 'running beforeRender hook');
    return (0, _when2.default)(this.init.beforeRender(utils, this.config));
  }
}

function readTemplateFiles(target) {
  this.sprout.emit('msg', 'reading target directory');
  return readdirp({
    root: target,
    directoryFilter: ['!.git', '!node_modules']
  });
}

function removeIgnoredFiles(result) {
  var _this6 = this;

  return _lodash2.default.filter(result.files, function (file) {
    if (_this6.init.ignore) {
      _this6.init.ignore = Array.prototype.concat(_this6.init.ignore);
      for (var i = 0; i < _this6.init.ignore.length; i++) {
        if ((0, _minimatch2.default)(file.path, _this6.init.ignore[i])) {
          return false;
        }
      }
    }
    return true;
  });
}

function writeTemplateFiles(utils, files) {
  var _this7 = this;

  return _when2.default.map(files, function (file) {
    _this7.sprout.emit('msg', 'reading ' + file.fullPath);

    if (!(0, _helpers.isBinaryFile)(file.fullPath)) {
      _this7.sprout.emit('msg', 'reading ' + file.fullPath);
      return utils.target.read(file.path).then(function (output) {
        _this7.sprout.emit('msg', 'writing ' + file.fullPath);
        return utils.target.write(file.path, output, _this7.config);
      });
    }
  });
}

function runAfterHook(utils) {
  if (this.init.after) {
    this.sprout.emit('msg', 'running after hook');
    return (0, _when2.default)(this.init.after(utils, this.config));
  }
}

function validateGenerator(generator) {
  var generatorPath = _path2.default.join(this.generatorsPath, generator + '.js');

  if (!fs.existsSync(generatorPath)) {
    throw new Error('\'' + generator + '\' is not a generator in this template');
  }

  this.sprout.emit('msg', 'requiring \'' + generator + '\' generator');
  return require(generatorPath);
}

function executeGenerator(target, args, generator) {
  var utils = new _utils2.default(this.path, target);

  args = _lodash2.default.isArray(args) ? args : [];
  args.unshift(utils);

  // Call the generator, pass the Utils instance and the arguments.
  this.sprout.emit('msg', 'running ' + generator + ' generator');
  return generator.apply(null, args);
}

module.exports = Template;